[["index.html", "Sticky Pi, a high-frequency smart insect trap to study daily activity in the field Introduction", " Sticky Pi, a high-frequency smart insect trap to study daily activity in the field Quentin Geissmann 2022-01-27 Introduction The principle behind Sticky Pis Sticky Pis are smart sticky traps using a Raspberry Pi camera to automatically score when, which and where insects were captured (using modern AI tools). They take very frequent pictures (three per hour), which reveals much more information compared to traditional traps (such as insects' response to weather fluctuations and effect of the time of the day). Sticky Pis integrate into a scalable platform, where individual devices send their data to a centralised web-server. A single team can deploy multiple devices and compile large ecological datasets. The Sticky Pi project is a community open-source academic resource. They are affordable and can be easily adapted for research, teaching and applied for work. If you use Sticky Pis in your research, please cite our publication. "],["overview.html", "Platform Overview", " Platform Overview The Sticky Pi project contains several interconnected tools. A github organisation features the material (source code, data, CAD files, ...) for each individual tool. Here is a list of all the tools: Name Description sticky-pi-device The Hardware and software for the Sticky Pi cameras (i.e. device) sticky-pi-device-v2 The improved version of the smart traps (in development) sticky-pi-data-harvester The Hardware and software for the Data Harvester sticky-pi-data-harvester-v2 The improved version of the Data Harvester (in development) sticky-pi-api Server and client api and the docker services for the server webapps sticky-pi-ml Machine learning for the Sticky Pi project sticky-pi-manuscript Manuscipt material and experiments for the 2021 method publication sticky-pi.github.io Source code of this documentation TODO include image here: platform. A clickable svg would be great This is an overview of the main components of the platform. The details of each part will be explain further. Hardware Sticky Pi devices -- Takes pictures of traps and record environmental conditions Data harvester -- Manages devices and retrieve their data (in the field) Web server Database -- Stores image metadata as well as processing results, users... S3 server -- Store and serve image data and machine learning models API -- Parses client requests to put/get resources from the underlying database Webapp -- A frontend website to visualise/plot the images taken and processing results Nginx server -- Secures and routes connections between the above services and the outside world Analysis pipeline -- Pre-processes images in real time Machine Learning Universal Insect Detector -- Detects insect vs background, in all images Siamese Insect Matcher -- Tracks insect instances across imaged Insect Tuboid Classifier -- Predicts insect taxonomy from a tracked instance "],["hardware.html", "Hardware Device Data harvester 0.1 Using Sticky Pis", " Hardware This page describes how to build the two main components of the hardware: the Sticky Pi Device and the Data Harvester. Briefly, multiple Sticky Pis are deployed in the field. Each device stores its images on its own SD card. On a regular basis (e.g. weekly), experimenters use a data harvester to retrieve the data from multiple devices. Silently, the data harvester also syncs the location and time of the devices it communicates with. One Data Harvester may be used to maintain multiple traps. Multiple Data Harvesters can exist in the same platform (e.g. five experimenters, one harvester per experimenter, ten devices per experimenter). This section involve familiarity with 3D printing, electronics, DIY, ... We are working on streamlining the assembly process towards a more `off-the-shelf tool', but are generally happy to collaborate and help building devices -- do not hesitate to contact us. Device Overview Figure 1: Sticky Pi Device As you can see in Figure 1, the device has two main parts, which are connected with a ribbon cable: the camera box and the light box. A complete description of the parts, price and reference is available in our Bill of Material Note that all 3D-printed parts are available on our onshape repository where they can be exported in a variety of formats. You can also take a look at our schematic. Assembly The camera Box and light box can be assembled separately and swapped between devices (i.e. the light box acts as a plug and play module for the camera box). Camera box Figure 2: Needed parts for the camera box Burn our OS image onto the SD card (note you can also make your own from scratch image by adaptingthe scripts in). Danger Zone! Ensure you know what you are doing here. In particular, give the path to the correct drive otherwise you may wipe out the wrong drive, and lose data. On Unix-like systems, use lsblk to see all drives. To burn an SD card use our script like sh burn_image.sh -i &lt;PATH_TO_LOCAL_IMAGE&gt; -d &lt;DEVICE&gt;, where &lt;PATH_TO_LOCAL_IMAGE&gt; is the OS image you just downloaded, and &lt;DEVICE&gt; the SD card location e.g. /dev/mmcblk0 -- you need etcher-cli. Prepare the Raspberry Pi. Figure 3: Modifications to the Raspberry Pi Zero Solder 2x5 headers for the Real Time Clock on pins 1-10. Mount the clock (Figure 3A). Solder directly the IDC right angle connector onto the board on pins 35-40 (Figure 3A). On the back of the Raspberry pi board, use a jumper cable to solder GPIO pin 40 to +5V (this provides power to the Pi, Figure 3B) Figure 4: Mounting the Raspberry Pi on the sledge Use four screws to mount the pi on the &quot;Pi sledge&quot;. Plug the ribbon cable for the camera (Figure 4A). Fold the ribbon cable around the sledge as in the picture, and mount the camera with another four screws (Figure 4B-C) Insert the OS SD card (burnt as described above) Focus the camera. For those who want to assemble multiple devices, we recommend a &quot;camera focusing station&quot; that can adapt a Pi sledge and has a display, keyboard... This way, one can use raspivid in preview mode to check focus and alignment. Initialize your device (you can do that at the same time as focusing), which you can do with the Data harvester: Power the data harvester, and ensure the time is set (not it is in GMT/UTC). Plug it to the pi's USB port. Boot/power the pi. The data harvester should then display information, including the unique ID of the pi. It will be an eight-digit hexadecimal number (e.g. abcd0123). Make a couple of physical label with this tag and stick them to the box (and write them on the sledge). As part of the communication process, the clock of the raspberry pi will be updated (indeed the factory RTC is unset) Thread the 1x6 ribbon cable (it should be at least 50cm long) through the &quot;camera box&quot; before clamping the 2x3 IDC connector on each side. You want have the two connectors in the same orientation (i.e. a wire connect pin 1 of the left connector to pin 1 o the right connector -- and not pin 6): Plug the ITC connector on the Pi GPIO, and gently slide the Pi sledge inside the camera box, while pulling the slack cable from the outside. Note, at the stage, you can also add some desiccant inside the box to reduce fogging. Assemble the &quot;camera box lid&quot;: Figure 5: Assembly of the camera box lid Cut a glass microscope slide into a 25x25mm square with a glass cutter (e.g. with a 3d printed gauge and snaping tool and tool it takes just a few seconds, Figure 5A-C). Place the glass window on the slot, use masking tape or duct tape to cover the central area and the back. Cast a layer of epoxy resin, and let it set for a day this will embed the glass in the lid. Note that it makes sense to make multiple lids at the same time and avoid wasting time and epoxy (Figure 5D-E). Clean the lid. Optionally coat it with water repellent such as Rain-X Add calk at the junction between the lid and the box, screw the lid on the box. Also use calk to seal the 6x1 ribbon cable outlet. Coat the whole box with a layer of epoxy (note you can also chose to do that before assembly) Light box Needed parts for the light box Assemble our custom PCB: Figure 6: Assembly of the custom PCB Manufacture/order the PCB from the gerber files (Figure 6A) Prepare the timer (scratch the board to disable the built-in potentiometer) -- (red in Figure 6B). Solder all parts to the board. This should be fairly self explanatory from the labels (Figure 6C). Make a custom connection to our push button (red in Figure 6C). This is arguably a bit of a hack, but that allows us to mimic the built-in TLP5110 push button, with our own. Thread the push button (before soldering it, not to twist the cables) Screw the PCB to the bottom of the light box (be careful not to split the material, do not hesitate to use shorter screw). Figure 7: Assembly of the custom PCB Insert the battery connector (Figure 7A) Screw the Humidity and temperature sensor to the outside the box (Figure 7A-B). Glue the solar panel in the top slot Assemble the light diffuser: Figure 8: Assembly of the custom PCB Cut six 5V, white, led light strips (Figure 8A). On one side, cut away the + pad, and the - on the other side. Align all the + pads on the top, and solder them together, in parallel, with a transverse wire Solder the 1x2 header to be connected to our PCB as in the picture (the male pins will be protruding downward). Use superglue to glue the header to the diffuser (Figure 8B). Test setup: Connect a camera box, using the 1x6 cable. Plug the light diffuser (or just a placeholder 5v LED light for now). Plug a battery. You should see the LED of the timer glowing (if not, press the push button to force reset the timer). After less than a minute, the The flash should be triggered, and the timer should shut down. Pressing the push button should restart the whole process. If left untouched, this should happen every 20min, approximately. QC and troubleshooting Controlling the assembly before deployment in the field will save you a lot of trouble. A few suggestions: Plug all devices, and press the push button to initiate the image acquisition. Ensure all devices flash. The light should blink twice. If the light does not blink. Check power/timer/light connection If the light blinks more than twice, the device is reporting an error. Typically, the camera cannot be found. Plug the Data Harvester and boot a device you want to test. Data transfer should be initiated. Check the label of the pi matches the ID displayed by the harvester. Monitor image transfer. Once all devices have been harvested, retrieve the memory stick of the harvester and inspect the content. There should be one directory for each device Each directory contains all the pictures for this device and a log file Open the log file to check no errors were reported The name of each image contains the time in UTC. Ensure the time is correct. Open the images to check exposure, focus,... The environmental data (temperature, relative humidity, GPS coordinates and other meta variables) are encoded in the exif metadata inside the &quot;Make&quot; field (Sometime, though rarely, the temperature/humidity sensor fails, so you may have missing values). Data harvester The data harvester is a portable tool to retrieve the data from the Sticky Pis. It is a (micro) computer running custom server that are available to the devices through a wifi network (hotspot). Figure 9: Sticky Pi Harvester schematic Figure 9 show how the different hardware parts interact. The parts we used are described in the Bill of Material. Role of each part: * Raspberry Pi 4 -- the core computer * RTC -- Real Time Clock: persistent time. * Memory stick -- external drive where all the images will be saved. * Mini Router -- connect the harvester with the Sticky Pis during data transfer. * Push Button -- to turn the Raspberyy Pi off * GPS -- optional, get geolocation * Display --optional, show the data harvseter webpage (can be accessed with other devices on the network at 192.168.8.2) Rapsberry Pi Download our our OS image and burn it on an SD card Format the USB stick to make a single ext4 partition In the new partition you created, create a file named .api-credentials.env and fill it with: SPI_API_HOSTNAME=&lt;the hostname of the API server&gt; SPI_API_USERNAME=&lt;a username for this data harvester&gt; SPI_API_PASSWORD=&lt;the password for this data harvester&gt; This will allow the data harvester to automatically upload the new images to your sever. This implies you have set up a server, and have created at least one user, which is described the webserver section. Router Set the name of the wifi network to sticky-pi-net, and the password to sticky-pi (this is to match the devices' environment variables). Ensure the subnet is 192.168.8. (the ip address of the router should then be 192.168.8.1). Write down the MAC address of the Raspberry Pi ethernet port (you can do that by using the ifconfig eth0 command, and spot a six-fields number looking like aa:db:e1:00:01:23). In the DNS menu reserve the IP address 192.168.8.2 to the mac address of the eth0 port you just retrieved Assembly A simple way to make the device is to connect the parts according to the schematics, and arrange them in a junction box like: Figure 10: Sticky Pi Harvester Assembled QC and troubleshooting You should be able to see a wifi network named sticky-pi-net and log on to is using the password sticky-pi using any device (phone, table, laptop). Then, when you connect to http://192.168.8.2 a webpage should display the data harvester status. 0.1 Using Sticky Pis Assuming you have a data harvester and at least one Sticky Pi. You can plug your Sticky Pi, which should begin to take pictures every 20 min. Pushing its button will force it to take a picture and go back to sleep it should take ~40s between when you press the button and when the device shouts the picture (you should see a white flash). If the device turns on and detect a Data Harvester, it will send all the new data automatically. The progress can be monitored on the Harvester webpage. "],["web-server.html", "Web Server General description Deployment Additional information", " Web Server This page describes how to deploy and maintain the web server. As much as we try to streamline this process, deploying our web server on the cloud does require some familiarity with Unix/Linux systems, Docker. We are open for collaboration and may be able to help you deploy your server, so do not hesitate to contact us. First, we describe the general function of the server. Second, we explain how to deploy and test it. Last, for completeness, we provide additional information on the individual components. General description Here is a schematics of how these services interact: Figure 11: Schematics of the web server services As shown in Figure 11, the web server is a suite of docker containers. The entry point is an Nginx server, spi_nginx, routes requests to the appropriate service: spi_api &lt;- api.* -- our overall API server (i.e. a server that handles client requests to, for instance, upload/download images, create new users, retrieve image metadata, etc). spi_webapp &lt;- webapp.* -- an Rshiny web interface to visualize data in real time. spi_s3 &lt;- s3.* -- an optional local s3 server, using localstack. This is an alternative to subscribe to a commercial s3 server. The other services are not routed (i.e must not be accessible by external users): spi_db -- a mariadb database that stores image metadata, user data, processing results, ... spi_uid -- a service that automatically pre-process all images, running the Universal Insect Detector, to segment insects vs background. certbot -- a service based on certbot that issues and renews SSL certificates in the background (for HTTPS) Deployment Github repository The all the source code needed for deployment can be found on the sticky-pi-api github repository. It contains two important subdirectories: src, a python package used to create the API, and server, a set of docker services orchestrated with docker compose. For deployment, we only care about the server -- if you are interested, the API is documented on readthedoc, but it should only concern you if you want to take part in development. Typically, you would clone this repository on your host. Hosting The simplest way to deploy the Sticky Pi server stack is on a remote Linux virtual machine. Perhaps your institution provides some cloud hosting, for instance Compute Canada Cloud, or you can opt for a commercial cloud provider. You can also decide to run the server on a custom machine within a restricted network. Security A remote web resources implies security considerations: Your host should use firewalls, the web-server only needs ports 80 (http) and 443 (https) open Ensure you use long, high entropy, passwords Update your host system Use ssh keys rather than passwords Configuration and important files Within the server directory, there are a few noticeable files we will describe: deploy.sh -- A script you can run to deploy the whole stack. More details later. docker-compose.yml -- The base docker-compose configuration file. docker-compose.prod.yml -- The specification of the above file, for production. .env -- An overall configuration file defining. You will need to modify some variables in it. .secret.env -- Contains credentials. For security reasons, this file does not exist yet you need to create it. Do not share this file, and ensure the permissions are restrictive. .env file You need to create a directory that will contain all the server data (except the s3-hosted files). Set LOCAL_VOLUME_ROOT in the .env file accordingly: LOCAL_VOLUME_ROOT=/your/sticky-pi/root/dirctory. In order to encrypt data flow between client and server, we enforce https. That implies the registration of a domain name. Typically, you want to: Ensure your cloud provider can provide a static/floating IP address for your instance, say 111.112.113.114. Find a DNS provider and register your domain name, say sticky.net. Use your DNS provider to create two A records: sticky.net -&gt; 111.112.113.114 and *.sticky.net -&gt; 111.112.113.114 Define ROOT_DOMAIN_NAME in the .env file to your registered domain name. E.g. ROOT_DOMAIN_NAME=sticky.net .secret.env file Create or add to .secret.env file the variables by modifying this template: # En encryption key can be any long sting of ascii characters, # e.g. something like `cfbewif7y8rfy4w3aNIKFW9Yfh89HFN9` SECRET_API_KEY= # Your S3 host. We will describe further the difference between # external and local S3 provider # For local option we can set # S3_HOST=s3.${ROOT_DOMAIN_NAME} # for remote option this would be a hostname like `my-s3.provider.com` S3_HOST= # For local s3 option, you want to define arbitrary keys: # e.g. S3_ACCESS_KEY=fnwfnoAEVikenAV and # S3_PRIVATE_KEY=cfweavb87eabv8uehabv98hwAW7 # For remote option, you will need to issue a key pair and paste it S3_ACCESS_KEY= S3_PRIVATE_KEY= # An arbitrary password, only used internally # Should be more than 10-characters long MYSQL_PASSWORD= # Another arbitrary password, only used internally # Should be more than 10-characters long API_ADMIN_PASSWORD= # Your email address (or the main admin&#39;s) ADMIN_EMAIL= # The name of the S3 bucket storing the images # and other binary files. E.g. `sticky-pi-prod` S3_BUCKET_NAME= # An arbitrary password for the special user/internal bot `uid`, # which can preprocess images automatically (universal insect detector). # Should be more than 10-characters long UID_PASSWORD= Alternative local S3 server Our recommended option is to use an external provider for S3. However, you can also run your own S3 as a docker container. To do that you just need to set S3_HOST=s3.${ROOT_DOMAIN_NAME} in the .secret.env file. Your data will be stored, by default on ${LOCAL_VOLUME_ROOT}/s3. Beware that overall data can be large -- typically [1, 2] GB per device per week. Deploy script Once we have set up the environment variables, we are ready to deploy. For convenience, we provide a script: server/deploy.sh that should be used this way for a production server: # sh deploy.sh prod-init # sh deploy.sh prod prod-init initializes SSL certificates. You should need to do that only once. If you want to subsequently restart/redeploy the server, just run sh deploy.sh prod. The first time, it may take a wile to build all the docker images. Once all the images have been built, ensure containers are running using docker ps. you can also debug and check the logs by using docker logs &lt;service_name&gt;. Check the API The simplest way to test the API end to end is to use cURL -- you could also use our python client. For instance, we can ask the API to issue a temporary logging token for the admin user. Replace &lt;API_ADMIN_PASSWORD&gt; and &lt;ROOT_DOMAIN_NAME&gt; by their value (same as in .secret.env). curl --user admin:&lt;API_ADMIN_PASSWORD&gt; -X POST https://api.&lt;ROOT_DOMAIN_NAME&gt;/get_token This should return a json dictionary with the fields &quot;expiration&quot; and &quot;token&quot;. If this does not work, stop here, and debug. Create users We can also use cURL to create users. For instance, to create a read only user named spi, with password R3ad_0nly, and no email address, we can run: curl --user admin:&lt;API_ADMIN_PASSWORD&gt; -X POST -H &quot;Content-Type: application/json&quot; -d &#39;[{&quot;username&quot;: &quot;spi&quot;, &quot;password&quot;: &quot;R3ad_0nly&quot;, &quot;is_admin&quot;: 0, &quot;email&quot;: &quot;&quot;, &quot;can_write&quot;:0}]&#39; https://api.&lt;ROOT_DOMAIN_NAME&gt;/put_users &quot;can_write&quot;:1 would create a user that can write, and &quot;is_admin&quot;: 1, an admin user (e.g. that can create other users). Note that you will not be able to retrieve a user's password as passwords are internally encrypted. If a password is lost, the only way to log in is to reset it. You can list users with: curl --user admin:&lt;API_ADMIN_PASSWORD&gt; -X POST https://api.sticky-pi.com/get_users You can test users by requesting a token, using curl as above, replacing --user admin:&lt;API_ADMIN_PASSWORD&gt;, by --user &lt;USERNAME&gt;:&lt;USER_PASSWORD&gt;. Backups The raw image data is on the s3 server. Manual backups/archives can be done by downlaoding all data to a separate resource/hard drive/... with tools such as s3cmd, using your credentials. In order to backup mariadb, you can use the deploy script: #sh deploy.sh mysql-backup This will create a file like spi_db.dump.YYYY-MM-DD.sql.gz in the current working directory -- that you then manually copy/archive. In case of catastrofic failure, the database could be restored with it. Additional information Database The database (spi_db) is the stock MariaDB. The database data is mounted on a persistent directory on the host: ${LOCAL_VOLUME_ROOT}/mysql in the host maps /var/lib/mysql in the container. Nginx Nginx (spi_nginx) is the stock Nginx. We use a custom configuration file to define routing (nginx/nging.conf-template). Note that this is a template file where we inject environment variable at built time. You should not need to modify the configuration file for standard deployment API The API (spi_api) is a uwsgi + flask server. The main file is api/app.py. This server depends extensively on our python package, sticky_pi_api. Note that the API and client are packaged together, which allows us to use mock local API vs remote API. Universal Insect Detector The UID (spi_uid) is a simple python script (ml/uid.py) that uses the API client and the our sticky_pi_ml package. It fetches the images that are not annotated (or obsolete) from client, analyse them, and upload the results (to the database, through the API). This process runs automatically. Note that you need to have either trained the UID or download a reference model for this service to work. We explain how to set-up ML resources in a dedicated section. Webapp The Webapp (spi_webapp) is an Rshiny interactive website. It is mainly designed to visualise image and processing data. Typically hundreds of images are acquired every week, this interface allows you to select a date range to display a plot of environmental conditions and overlay images as well as UID results. This is very helpful to ensure the quality of your data in real time. The webapp will be available at webapp.&lt;ROOT_DOMAIN_NAME&gt;, as defined in hosting. "],["ml.html", "Machine Learning", " Machine Learning The machine learning algorithms are described in the Sticky Pi manuscript. The model files and datasets used in the publication are available on Zenodo. Our source code is publically available on github. We are happy to provide assistance to use and extend our tools to specific contexts. "],["outreach.html", "Outreach June-August 2021", " Outreach Sticky Pis are built on top of community hardware such as Arduino and Raspberry Pi as well as open-source software such as Python. We share their educational spirit and consider it our work to raise awareness about insect ecology and discuss how new technologies can indeed intersect with the study of insects. June-August 2021 Figure 12: Sticky Pi at the UBC Research Farm In 2021, we were able to deploy 36 Sticky Pi traps at the University of British Columbia farm, a research, teaching and learning space, located on the traditional, ancestral, and unceded territory of the hən̓q̓əmin̓əm̓-speaking xʷməθkʷəy̓əm (Musqueam) people, and housed under the Faculty of Land and Food Systems. Our goal was to monitor insect populations in an organic strawberry field interspersed with different flowers (aka intercropping). Neighbouring flowers are known to attract pollinators and other beneficial insects that can then help to control pests. We wanted to study how different flowers such as buckwheat, clover and dill indirectly mitigate the infestation by the spotted wing drosophila (a voracious fruit pest). Intercropping could be a tool within a suite of integrated solutions to maintain production whilst reducing the environmental impact of agriculture. The experiment is ongoing and we will communicate the results later this year. "],["community.html", "Issues and community Citation Having troubles Contributing Contact", " Issues and community Citation Sticky Pis are a research tool. As such, they are -- and will always be -- as free and open-source as possible. If you use Sticky Pis as part of your research, please cite our reference publication. Having troubles If you are having issues or you want help with something, the best thing you can do is fill an &quot;issue&quot; on the github repository of the relevant tool. Contributing We welcome external contributions and hope Sticky Pis develops as part of a computational entomology community. There are several ways you can contribute: By requesting features and reporting bugs through the github issue system By sending pull requests to preexisting tools By volunteering to maintain/develop a tools Contact Sticky Pis are developed at the Plant-Insect Ecology and Evolution lab at UBC, Vancouver in collaboration with the Haney Lab and the Insect Biocontrol lab. Do not hesitate to contact Quentin Geissmann, the main contributor of the project for inquiries. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
